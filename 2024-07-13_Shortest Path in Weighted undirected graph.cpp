
//https://www.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
//13 july 24
//comments generated BY CLAUDE 3.5 SONNET AIIIIIIIIIIIIIi~!!!

#define INF 1e9
class Solution {
  public:
    vector<int> shortestPath(int n, int m, vector<vector<int>>& edges) {
        // Code here
        vector<int> parent(n), dist(n,INF);
        for(int i=0;i<n;++i){
            parent[i]=i;
        }
        
        // vector<vector<pair<int,int>>> graph[n];
        vector<pair<int,int>> graph[n];
        
        // Build the graph from the given edges
        for(auto it: edges){
            int u = it[0] - 1, v = it[1]-1, w= it[2]; 
            // Subtract 1 because nodes are 1-indexed in input
            graph[u].push_back({v,w});  // Add edge u -> v with weight w
            graph[v].push_back({u,w});// Add edge v -> u with weight w (undirected graph)
        }
        // Initialize a queue for BFS
        queue <vector<int>> q;
        dist[0]=0;
        // q.push({0,0});
        
         // Push starting node to queue: {distance, node}
        q.push({0,0});
        
         // Start BFS
        while(q.size() > 0){
            vector<int> it=q.front();
            int nodewt=it[0];
            int node=it[1];
            q.pop();
        
            // Explore all neighbors of the current node
            for(auto i : graph[node]){
                int adjnode=i.first; // Adjacent node
                int wt=i.second; // Weight of edge to adjacent node
                
                 // If we found a shorter path to the adjacent node
                if(dist[adjnode]>wt+nodewt){
                    dist[adjnode]=wt+nodewt; // Update distance
                    parent[adjnode]=node;// Update parent
                    q.push({dist[adjnode],adjnode});// Push to queue for further exploration
                }
            }
        }
        
         // If we couldn't reach the last node (n-1), return -1
            if(dist[n-1]==INF){
                return {-1};
            }
            
            // Reconstruct the path
            vector<int>path;
            int r=n-1;  // Start from the last node
            while(r!=0 and r!= parent[r]){ // Traverse until we reach the start or a cycle
                path.push_back(r+1); // Add 1 because nodes are 1-indexed in output
                r=parent[r];
            }
            path.push_back(1);
            reverse(path.begin(),path.end());  // Reverse to get path from start to end
            
             // Prepare the final answer
             
             vector<int> ans;
            ans.push_back(dist[n-1]); // First element is the total distance
            for(auto i: path){
                ans.push_back(i); // Add all nodes in the path
            }
        
        return ans;
    }
};